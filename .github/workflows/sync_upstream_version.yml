name: Sync fork with upstream release (ACR + Managed Identity)

on:
  workflow_dispatch:
    inputs:
      force_tag:
        description: "Override: sync to this upstream tag (e.g., v0.4.2). Leave blank for latest stable."
        required: false
        default: ""
      include_prereleases:
        description: "Consider pre-releases? (true/false)"
        required: false
        default: "false"
  schedule:
    - cron: "23 4 * * *"  # daily 04:23 UTC

concurrency:
  group: sync-upstream
  cancel-in-progress: true

permissions:
  id-token: write     # required for OIDC login to Azure
  contents: write
  pull-requests: write

env:
  # ==== Customize here ====
  UPSTREAM_REPO: open-webui/open-webui
  DEPLOY_BRANCH: main

  # ACR config (we'll resolve loginServer dynamically)
  ACR_NAME: crcimaopenwebui                # your ACR resource name (not the FQDN)
  IMAGE_REPO: open-webui-cima              # repository path inside ACR (e.g., myapp/backend)

  # Control steps
  PUSH_IMAGE: "true"

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.DEPLOY_BRANCH }}

      - name: Configure Git author
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Read previous upstream tag
        id: prev
        run: |
          [[ -f .upstream-version ]] || { echo "::error::.upstream-version missing"; exit 1; }
          prev_tag=$(tr -d ' \t\n' < .upstream-version)
          echo "prev_tag=$prev_tag" >> "$GITHUB_OUTPUT"
          echo "Baseline upstream tag: $prev_tag"

      - name: Add upstream remote & fetch tags
        run: |
          git remote add upstream https://github.com/${{ env.UPSTREAM_REPO }}.git || true
          git fetch upstream --tags --force --prune

      - name: Resolve latest upstream tag
        id: latest
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          force_tag="${{ github.event.inputs.force_tag }}"
          include_pre="${{ github.event.inputs.include_prereleases || 'false' }}"
          if [[ -n "$force_tag" ]]; then
            echo "latest_tag=$force_tag" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ "$include_pre" == "true" ]]; then
            tag=$(gh api repos/${{ env.UPSTREAM_REPO }}/releases \
              --jq '[.[] | select(.draft==false)] | sort_by(.created_at) | last.tag_name')
          else
            tag=$(gh api repos/${{ env.UPSTREAM_REPO }}/releases \
              --jq '[.[] | select(.draft==false and .prerelease==false)] | sort_by(.created_at) | last.tag_name')
          fi
          [[ -n "$tag" && "$tag" != "null" ]] || { echo "::error::No suitable release tag found"; exit 1; }
          echo "latest_tag=$tag" >> "$GITHUB_OUTPUT"
          echo "Latest upstream tag: $tag"

      - name: Short-circuit if already on latest
        if: steps.latest.outputs.latest_tag == steps.prev.outputs.prev_tag
        run: echo "Already up-to-date with ${{ steps.prev.outputs.prev_tag }}"

      - name: Create update branch from upstream tag
        if: steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        run: |
          new_tag="${{ steps.latest.outputs.latest_tag }}"
          git checkout -b "update/${new_tag}" "refs/tags/${new_tag}"

      - name: Compute custom commits since baseline
        id: custom
        if: steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        run: |
          prev="${{ steps.prev.outputs.prev_tag }}"
          # Collect commits unique to DEPLOY_BRANCH since prev_tag (old baseline)
          commits=$(git rev-list --reverse --no-merges "${prev}..origin/${{ env.DEPLOY_BRANCH }}")

          # Convert newlines to spaces for safe GitHub output
          commits_space=$(echo "$commits" | tr '\n' ' ' | xargs)
          echo "commits=$commits_space" >> "$GITHUB_OUTPUT"

          echo "Custom commits (oldest → newest):"
          echo "$commits"


      - name: Cherry-pick custom commits (prefer my changes; skip specific commits; with exceptions)
        if: steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag && steps.custom.outputs.commits != ''
        env:
          # commits to SKIP (prefixes or full SHAs, one per line)
          SKIP_COMMITS: |
            a07f1d0d7
            b5eca896f
          KEEP_OURS_PATHS: |
            src/lib/components/chat/Chat.svelte
        run: |
          set -e
      
          in_skip_list() {
            local sha="$1"
            while IFS= read -r pat; do
              [[ -z "$pat" ]] && continue
              # prefix match (handles short vs full SHA)
              if [[ "$sha" == "$pat"* ]]; then
                return 0
              fi
            done <<< "${SKIP_COMMITS}"
            return 1
          }
      
          is_exception() {
            local file="$1"
            while IFS= read -r pat; do
              [[ -z "$pat" ]] && continue
              [[ "$file" == "$pat" ]] && return 0
            done <<< "${KEEP_OURS_PATHS}"
            return 1
          }
      
          # helper to detect empty worktree/index
          is_clean() {
            git diff --quiet && git diff --cached --quiet
          }
      
          for c in ${{ steps.custom.outputs.commits }}; do
            if in_skip_list "$c"; then
              echo "Skipping $c (on skip list)"
              continue
            fi
      
            echo "Cherry-picking $c (prefer my changes)"
            if git cherry-pick -x -X theirs "$c"; then
              continue
            fi
      
            echo "Cherry-pick failed on $c — inspecting conflicts..."
            conflicted=$(git diff --name-only --diff-filter=U || true)
      
            # Empty cherry-pick? skip it.
            if [[ -z "$conflicted" ]] && is_clean; then
              echo "Empty cherry-pick; skipping."
              git cherry-pick --skip
              continue
            fi
      
            if [[ -z "$conflicted" ]]; then
              echo "::error::Cherry-pick failed but no conflicted paths found."
              git cherry-pick --abort
              exit 2
            fi
      
            echo "Conflicted files:"
            echo "$conflicted"
      
            # Resolve: default keep *theirs* (your commit); exceptions keep *ours* (upstream)
            while IFS= read -r f; do
              [[ -z "$f" ]] && continue
              if is_exception "$f"; then
                echo "  - Keeping *ours* (upstream) for $f"
                git checkout --ours -- "$f" || true
              else
                echo "  - Keeping *theirs* (my commit) for $f"
                git checkout --theirs -- "$f" || true
              fi
              git add -- "$f"
            done <<< "$conflicted"
      
            if is_clean; then
              echo "After resolution, patch is empty. Skipping."
              git cherry-pick --skip
            else
              git cherry-pick --continue
            fi
          done
      - name: Update baseline marker
        if: steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        run: |
          echo "${{ steps.latest.outputs.latest_tag }}" > .upstream-version
          git add .upstream-version
          git commit -m "chore: bump upstream to ${{ steps.latest.outputs.latest_tag }}"

      # ---------- Azure login via OIDC (Managed Identity / Federated Credential) ----------
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # Resolve the ACR login server so we don't hardcode it
      - name: Resolve ACR login server
        id: acr
        run: |
          login_server=$(az acr show --name "${{ env.ACR_NAME }}" --query loginServer -o tsv)
          echo "login_server=$login_server" >> "$GITHUB_OUTPUT"
          echo "ACR login server: $login_server"

      - name: ACR docker login (managed identity)
        run: |
          az acr login --name "${{ env.ACR_NAME }}"

      # ---------- Build & Push to ACR ----------
      - name: Set image refs
        id: img
        if: env.PUSH_IMAGE == 'true' && steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        run: |
          tag="${{ steps.latest.outputs.latest_tag }}"
          server="${{ steps.acr.outputs.login_server }}"
          echo "name=${server}/${{ env.IMAGE_REPO }}:${tag}" >> "$GITHUB_OUTPUT"
          echo "latest=${server}/${{ env.IMAGE_REPO }}:latest" >> "$GITHUB_OUTPUT"

      - name: Build & push image (ACR)
        if: env.PUSH_IMAGE == 'true' && steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ steps.img.outputs.name }}
            ${{ steps.img.outputs.latest }}
