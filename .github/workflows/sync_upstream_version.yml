name: Sync fork with upstream release (ACR + Managed Identity)

on:
  workflow_dispatch:
    inputs:
      force_tag:
        description: "Override: sync to this upstream tag (e.g., v0.4.2). Leave blank for latest stable."
        required: false
        default: ""
      include_prereleases:
        description: "Consider pre-releases? (true/false)"
        required: false
        default: "false"
  schedule:
    - cron: "23 4 * * *"  # daily 04:23 UTC

concurrency:
  group: sync-upstream
  cancel-in-progress: true

permissions:
  id-token: write     # required for OIDC login to Azure
  contents: write
  pull-requests: write

env:
  # ==== Customize here ====
  UPSTREAM_REPO: open-webui/open-webui
  DEPLOY_BRANCH: main

  # ACR config (we'll resolve loginServer dynamically)
  ACR_NAME: crcimaopenwebui                # your ACR resource name (not the FQDN)
  IMAGE_REPO: open-webui-cima              # repository path inside ACR (e.g., myapp/backend)

  # Control steps
  PUSH_IMAGE: "true"

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.DEPLOY_BRANCH }}

      - name: Configure Git author
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Read previous upstream tag
        id: prev
        run: |
          [[ -f .upstream-version ]] || { echo "::error::.upstream-version missing"; exit 1; }
          prev_tag=$(tr -d ' \t\n' < .upstream-version)
          echo "prev_tag=$prev_tag" >> "$GITHUB_OUTPUT"
          echo "Baseline upstream tag: $prev_tag"

      - name: Add upstream remote & fetch tags
        run: |
          git remote add upstream https://github.com/${{ env.UPSTREAM_REPO }}.git || true
          git fetch upstream --tags --force --prune

      - name: Resolve latest upstream tag
        id: latest
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          force_tag="${{ github.event.inputs.force_tag }}"
          include_pre="${{ github.event.inputs.include_prereleases || 'false' }}"
          if [[ -n "$force_tag" ]]; then
            echo "latest_tag=$force_tag" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ "$include_pre" == "true" ]]; then
            tag=$(gh api repos/${{ env.UPSTREAM_REPO }}/releases \
              --jq '[.[] | select(.draft==false)] | sort_by(.created_at) | last.tag_name')
          else
            tag=$(gh api repos/${{ env.UPSTREAM_REPO }}/releases \
              --jq '[.[] | select(.draft==false and .prerelease==false)] | sort_by(.created_at) | last.tag_name')
          fi
          [[ -n "$tag" && "$tag" != "null" ]] || { echo "::error::No suitable release tag found"; exit 1; }
          echo "latest_tag=$tag" >> "$GITHUB_OUTPUT"
          echo "Latest upstream tag: $tag"

      - name: Short-circuit if already on latest
        if: steps.latest.outputs.latest_tag == steps.prev.outputs.prev_tag
        run: echo "Already up-to-date with ${{ steps.prev.outputs.prev_tag }}"

      - name: Create update branch from upstream tag
        if: steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        run: |
          new_tag="${{ steps.latest.outputs.latest_tag }}"
          git checkout -b "update/${new_tag}" "refs/tags/${new_tag}"

      - name: Compute custom commits since baseline
        id: custom
        if: steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        run: |
          prev="${{ steps.prev.outputs.prev_tag }}"
          # Collect commits unique to DEPLOY_BRANCH since prev_tag (old baseline)
          commits=$(git rev-list --reverse --no-merges "${prev}..origin/${{ env.DEPLOY_BRANCH }}")

          # Convert newlines to spaces for safe GitHub output
          commits_space=$(echo "$commits" | tr '\n' ' ' | xargs)
          echo "commits=$commits_space" >> "$GITHUB_OUTPUT"

          echo "Custom commits (oldest → newest):"
          echo "$commits"


      - name: Cherry-pick custom commits (prefer my changes; handle empty commits)
        if: steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag && steps.custom.outputs.commits != ''
        run: |
          set -e
      
          # Helper: check if working tree & index are clean
          is_clean() {
            git diff --quiet && git diff --cached --quiet
          }
      
          for c in ${{ steps.custom.outputs.commits }}; do
            echo "Cherry-picking $c (prefer my changes)"
            if git cherry-pick -x -X theirs "$c"; then
              # Applied cleanly
              continue
            fi
      
            echo "Cherry-pick failed on $c — inspecting..."
            # If there's nothing to commit (empty patch), skip it
            if is_clean; then
              echo "No changes produced by $c (empty cherry-pick). Skipping."
              git cherry-pick --skip
              continue
            fi
      
            # Otherwise, we have conflicts; auto-resolve by keeping *theirs* (your commit) everywhere
            conflicted=$(git diff --name-only --diff-filter=U || true)
            if [[ -z "$conflicted" ]]; then
              echo "::error::Cherry-pick failed but no conflicted paths found (and tree not clean). Aborting."
              git cherry-pick --abort
              exit 2
            fi
      
            echo "Conflicted files:"
            echo "$conflicted"
      
            # Keep *theirs* (your change) for all conflicted files
            while IFS= read -r f; do
              [[ -z "$f" ]] && continue
              echo "  - Keeping *theirs* for $f"
              git checkout --theirs -- "$f" || true
              git add -- "$f"
            done <<< "$conflicted"
      
            # If after resolving there are still no changes (rare), skip; else continue
            if is_clean; then
              echo "After resolution, patch is empty. Skipping $c."
              git cherry-pick --skip
            else
              git cherry-pick --continue
            fi
          done
      - name: Update baseline marker
        if: steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        run: |
          echo "${{ steps.latest.outputs.latest_tag }}" > .upstream-version
          git add .upstream-version
          git commit -m "chore: bump upstream to ${{ steps.latest.outputs.latest_tag }}"

      # ---------- Azure login via OIDC (Managed Identity / Federated Credential) ----------
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # Resolve the ACR login server so we don't hardcode it
      - name: Resolve ACR login server
        id: acr
        run: |
          login_server=$(az acr show --name "${{ env.ACR_NAME }}" --query loginServer -o tsv)
          echo "login_server=$login_server" >> "$GITHUB_OUTPUT"
          echo "ACR login server: $login_server"

      - name: ACR docker login (managed identity)
        run: |
          az acr login --name "${{ env.ACR_NAME }}"

      # ---------- Build & Push to ACR ----------
      - name: Set image refs
        id: img
        if: env.PUSH_IMAGE == 'true' && steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        run: |
          tag="${{ steps.latest.outputs.latest_tag }}"
          server="${{ steps.acr.outputs.login_server }}"
          echo "name=${server}/${{ env.IMAGE_REPO }}:${tag}" >> "$GITHUB_OUTPUT"
          echo "latest=${server}/${{ env.IMAGE_REPO }}:latest" >> "$GITHUB_OUTPUT"

      - name: Build & push image (ACR)
        if: env.PUSH_IMAGE == 'true' && steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ steps.img.outputs.name }}
            ${{ steps.img.outputs.latest }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
