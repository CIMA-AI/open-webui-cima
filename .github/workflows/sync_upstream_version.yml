name: Sync fork with upstream release (ACR + Managed Identity)

on:
  workflow_dispatch:
    inputs:
      force_tag:
        description: "Override: sync to this upstream tag (e.g., v0.4.2). Leave blank for latest stable."
        required: false
        default: ""
      include_prereleases:
        description: "Consider pre-releases? (true/false)"
        required: false
        default: "false"
  schedule:
    - cron: "23 4 * * *"  # daily 04:23 UTC

concurrency:
  group: sync-upstream
  cancel-in-progress: true

permissions:
  id-token: write     # required for OIDC login to Azure
  contents: write
  pull-requests: write

env:
  # ==== Customize here ====
  UPSTREAM_REPO: open-webui/open-webui
  DEPLOY_BRANCH: main

  # ACR config (we'll resolve loginServer dynamically)
  ACR_NAME: crcimaopenwebui                # your ACR resource name (not the FQDN)
  IMAGE_REPO: open-webui-cima              # repository path inside ACR (e.g., myapp/backend)

  # Control steps
  PUSH_IMAGE: "true"

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.DEPLOY_BRANCH }}

      - name: Configure Git author
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Read previous upstream tag
        id: prev
        run: |
          [[ -f .upstream-version ]] || { echo "::error::.upstream-version missing"; exit 1; }
          prev_tag=$(tr -d ' \t\n' < .upstream-version)
          echo "prev_tag=$prev_tag" >> "$GITHUB_OUTPUT"
          echo "Baseline upstream tag: $prev_tag"

      - name: Add upstream remote & fetch tags
        run: |
          git remote add upstream https://github.com/${{ env.UPSTREAM_REPO }}.git || true
          git fetch upstream --tags --force --prune

      - name: Resolve latest upstream tag
        id: latest
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          force_tag="${{ github.event.inputs.force_tag }}"
          include_pre="${{ github.event.inputs.include_prereleases || 'false' }}"
          if [[ -n "$force_tag" ]]; then
            echo "latest_tag=$force_tag" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ "$include_pre" == "true" ]]; then
            tag=$(gh api repos/${{ env.UPSTREAM_REPO }}/releases \
              --jq '[.[] | select(.draft==false)] | sort_by(.created_at) | last.tag_name')
          else
            tag=$(gh api repos/${{ env.UPSTREAM_REPO }}/releases \
              --jq '[.[] | select(.draft==false and .prerelease==false)] | sort_by(.created_at) | last.tag_name')
          fi
          [[ -n "$tag" && "$tag" != "null" ]] || { echo "::error::No suitable release tag found"; exit 1; }
          echo "latest_tag=$tag" >> "$GITHUB_OUTPUT"
          echo "Latest upstream tag: $tag"

      - name: Short-circuit if already on latest
        if: steps.latest.outputs.latest_tag == steps.prev.outputs.prev_tag
        run: echo "Already up-to-date with ${{ steps.prev.outputs.prev_tag }}"

      - name: Create update branch from upstream tag
        if: steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        run: |
          new_tag="${{ steps.latest.outputs.latest_tag }}"
          git checkout -b "update/${new_tag}" "refs/tags/${new_tag}"

      - name: Compute custom commits since baseline
        id: custom
        if: steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        run: |
          prev="${{ steps.prev.outputs.prev_tag }}"
          # Collect commits unique to DEPLOY_BRANCH since prev_tag (old baseline)
          commits=$(git rev-list --reverse --no-merges "${prev}..origin/${{ env.DEPLOY_BRANCH }}")

          # Convert newlines to spaces for safe GitHub output
          commits_space=$(echo "$commits" | tr '\n' ' ' | xargs)
          echo "commits=$commits_space" >> "$GITHUB_OUTPUT"

          echo "Custom commits (oldest → newest):"
          echo "$commits"

      - name: Cherry-pick custom commits (with conflict handler)
        if: steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag && steps.custom.outputs.commits != ''
        run: |
          set -e
          for c in ${{ steps.custom.outputs.commits }}; do
            echo "Cherry-picking $c"
            if git cherry-pick -x "$c"; then
              continue
            fi
      
            echo "Cherry-pick failed on $c — inspecting conflicts..."
            conflicted=$(git diff --name-only --diff-filter=U || true)
            echo "Conflicted files:"
            echo "$conflicted"
      
            # Case: your commit tried to delete a workflow that upstream modified
            if echo "$conflicted" | grep -qx '\.github/workflows/deploy-to-hf-spaces\.yml'; then
              echo "Auto-resolving by keeping upstream version of deploy-to-hf-spaces.yml"
              # Keep upstream's content of the file
              git checkout --theirs .github/workflows/deploy-to-hf-spaces.yml
              git add .github/workflows/deploy-to-hf-spaces.yml
              git cherry-pick --continue
              # Flag so we can disable it later
              echo "needs_disable=true" >> $GITHUB_ENV
            else
              echo "::error::Unhandled conflict. Aborting so you can resolve manually."
              git cherry-pick --abort
              exit 2
            fi
          done
      - name: Update baseline marker
        if: steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        run: |
          echo "${{ steps.latest.outputs.latest_tag }}" > .upstream-version
          git add .upstream-version
          git commit -m "chore: bump upstream to ${{ steps.latest.outputs.latest_tag }}"

      # ---------- Azure login via OIDC (Managed Identity / Federated Credential) ----------
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # Resolve the ACR login server so we don't hardcode it
      - name: Resolve ACR login server
        id: acr
        run: |
          login_server=$(az acr show --name "${{ env.ACR_NAME }}" --query loginServer -o tsv)
          echo "login_server=$login_server" >> "$GITHUB_OUTPUT"
          echo "ACR login server: $login_server"

      - name: ACR docker login (managed identity)
        run: |
          az acr login --name "${{ env.ACR_NAME }}"

      # ---------- Build & Push to ACR ----------
      - name: Set image refs
        id: img
        if: env.PUSH_IMAGE == 'true' && steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        run: |
          tag="${{ steps.latest.outputs.latest_tag }}"
          server="${{ steps.acr.outputs.login_server }}"
          echo "name=${server}/${{ env.IMAGE_REPO }}:${tag}" >> "$GITHUB_OUTPUT"
          echo "latest=${server}/${{ env.IMAGE_REPO }}:latest" >> "$GITHUB_OUTPUT"

      - name: Build & push image (ACR)
        if: env.PUSH_IMAGE == 'true' && steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ steps.img.outputs.name }}
            ${{ steps.img.outputs.latest }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      - name: Disable HF Spaces workflow (by renaming)
        if: env.needs_disable == 'true' && steps.latest.outputs.latest_tag != steps.prev.outputs.prev_tag
        run: |
          if [ -f .github/workflows/deploy-to-hf-spaces.yml ]; then
            git mv .github/workflows/deploy-to-hf-spaces.yml .github/workflows/deploy-to-hf-spaces.yml.disabled
            git commit -m "chore: disable HF Spaces workflow by renaming to .disabled"
          fi